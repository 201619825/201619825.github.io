<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>遗世、遇夕</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="遗世、遇夕">
<meta property="og:url" content="https://201619825.github.io/index.html">
<meta property="og:site_name" content="遗世、遇夕">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="遗世、遇夕">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="遗世、遇夕" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/default-avatar.jpg">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/highlight.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="fullpage" class="mobile-nav-right">
    
      <div id="wrapper" title="图片来自网络">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-right">
      
        <a class="nav-item" href="/" title
        
        >首页</a>
      
        <a class="nav-item" href="/archives" title
        
        >档案</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-right">
        <section id="main">
  
    <article id="post-java-tomcat-filter-color-parse" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/23/java-tomcat-filter-color-parse/">java filter 解析网关入参</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2022/12/23/java-tomcat-filter-color-parse/" class="article-date">
  <time datetime="2022-12-23T02:44:58.000Z" itemprop="datePublished">2022-12-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E5%AE%9D%E5%85%B8/">知识宝典</a>
  </div>

    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-mac" itemprop="articleBody">
      
        Java filter 解析网关入参
1. 前言 OncePerRequestFilter
一个Filter在对一次客户端请求request的处理中，常识上的理解，应该只被应用一次。这种理解很直观，也很合理，然而实际情况并非如此。Spring给出的解决方案是OncePerRequestFilter。如果想让一个Filter在一次请求处理的过程中只被应用一次，就让这个Filter继承自OncePerRequestFilter。Spring自身提供的这类的Filter,都继承自该过滤器基类。

 1. 解析网关body中入参，并继承HttpServletRequestWrapper修改入参传入
 
        
          <p class="article-more-link">
            <a href="/2022/12/23/java-tomcat-filter-color-parse/#more">阅读全文</a>
          </p>
        
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-java-jvm-config" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/09/java-jvm-config/">java-jvm-config</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2022/02/09/java-jvm-config/" class="article-date">
  <time datetime="2022-02-09T06:26:44.000Z" itemprop="datePublished">2022-02-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E5%AE%9D%E5%85%B8/">知识宝典</a>
  </div>

    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-mac" itemprop="articleBody">
      
        JVM参数调优
1. CMS垃圾回收器
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26


-Xms3G 
-Xmx3G 
-Xmn1G 
-XX:MaxPermSize=256M 
-XX:+UseParNewGC 
-XX:+UseConcMarkSweepGC 
-XX:+CMSClassUnloadingEnabled 
-XX:+UseCMSInitiatingOccupancyOnly 
-XX:CMSInitiatingOccupancyFraction=60 
-XX:ParallelGC
        
          <p class="article-more-link">
            <a href="/2022/02/09/java-jvm-config/#more">阅读全文</a>
          </p>
        
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-java-spi" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/10/23/java-spi/">Java SPI 应用</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2021/10/23/java-spi/" class="article-date">
  <time datetime="2021-10-23T02:21:22.000Z" itemprop="datePublished">2021-10-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E5%AE%9D%E5%85%B8/">知识宝典</a>
  </div>

    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-mac" itemprop="articleBody">
      
        Java SPI 应用
为什么要使用SPI
面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候不用在程序里动态指明，这就需要一种服务发现机制。java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制。这有点类似IOC的思想，将装配的控制权移到了程序之外。

SPI能做什么
利用SPI机制，sdk的开发者可以为使用者提供扩展点，使用者无需修改源码，有点类似Spring @ConditionalOnMissingBean 的意思

例如我们要
        
          <p class="article-more-link">
            <a href="/2021/10/23/java-spi/#more">阅读全文</a>
          </p>
        
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-self-spring-tag" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/05/self-spring-tag/">java 自定义spring标签</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2021/09/05/self-spring-tag/" class="article-date">
  <time datetime="2021-09-05T09:01:27.000Z" itemprop="datePublished">2021-09-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E5%AE%9D%E5%85%B8/">知识宝典</a>
  </div>

    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-mac" itemprop="articleBody">
      
        Java 自定义spring标签
前言
自定义标签可以说是spring提供的最大、最强的Hook（钩子），通俗的讲就是给后续小伙伴开发组件，提供一个标准公共可拔插”接口”，大家可以理解为手机充电器的工业标准口，为了方便各个充电器生产厂家生产，而制定的标准。
既然说自定义标签如此强大，我们在哪里应用的呢? 我们知道spring发展越来越强大，但核心的组件只有spring-core和spring-beans，那么有些人会问我们经常用的context，aop，tx不是吗？对的，这些都是在核心上做的扩展，而这些扩展恰恰是通过自定义标签实现扩展的，还有一些公共开源组件amq，redis，dubbo等等，
        
          <p class="article-more-link">
            <a href="/2021/09/05/self-spring-tag/#more">阅读全文</a>
          </p>
        
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-static-inner-class" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/30/static-inner-class/">静态内部类</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2021/08/30/static-inner-class/" class="article-date">
  <time datetime="2021-08-30T02:29:29.000Z" itemprop="datePublished">2021-08-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E5%AE%9D%E5%85%B8/">知识宝典</a>
  </div>

    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-mac" itemprop="articleBody">
      
        Java静态内部类
前言
内部类，即定义在一个类的内部的类。为什么有内部类呢？
我们知道，在java中类是单继承的，一个类只能继承另一个具体类或抽象类（可以实现多个接口）。这种设计的目的是因为在多继承中，当多个父类中有重复的属性或者方法时，子类的调用结果会含糊不清，因此用了单继承。
而使用内部类的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部
        
          <p class="article-more-link">
            <a href="/2021/08/30/static-inner-class/#more">阅读全文</a>
          </p>
        
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-mq-info1" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/03/mq-info1/">MQ的使用及介绍</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2021/07/03/mq-info1/" class="article-date">
  <time datetime="2021-07-03T09:08:54.000Z" itemprop="datePublished">2021-07-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E5%AE%9D%E5%85%B8/">知识宝典</a>
  </div>

    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-mac" itemprop="articleBody">
      
        MQ的使用及介绍
1. 前言
MQ：MessageQueue，消息队列。队列是一种FIFO先进先出的数据结构，消息由生产者发送到MQ进行排队，然后由消费者对消息进行处理，QQ，微信就是典型的MQ场景。
MQ的作用主要由三个方面：

 * 异步：能提高系统的响应速度和吞吐量。
 * 解耦：服务间解耦，可以减少服务间的影响，提高系统的稳定性和可扩展性（例如通过MQ消息，java服务去使用python的服务）。
 * 削峰：以稳定的系统资源应对突发的流量冲击（例如秒杀场景的流量交给MQ去处理）。
   MQ的缺点：
 * 系统的可用性降低，一旦MQ宕机，整个业务都会产生影响。高可用。
 * 系统的复
        
          <p class="article-more-link">
            <a href="/2021/07/03/mq-info1/#more">阅读全文</a>
          </p>
        
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-elsticSearch" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/22/elsticSearch/">ElasticSearch 概念及使用</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2021/06/22/elsticSearch/" class="article-date">
  <time datetime="2021-06-22T02:41:43.000Z" itemprop="datePublished">2021-06-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E5%AE%9D%E5%85%B8/">知识宝典</a>
  </div>

    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-mac" itemprop="articleBody">
      
        ElasticSearch 概念及使用
1. 前言
Elasticsearch 是一个分布式文档储存中间件，它不会将信息储存为列数据行，而是储存已序列化为 JSON 文档的复杂数据结构。当你在一个集群中有多个节点时，储存的文档分布在整个集群里面，并且立刻可以从任意节点去访问。

当文档被储存时，它将建立索引并且近实时（1s）被搜索。 Elasticsearch 使用一种被称为倒排索引的数据结构，该结构支持快速全文搜索。在倒排索引里列出了所有文档中出现的每一个唯一单词并分别标识了每个单词在哪一个文档中。

Elasticsearch 具备默认模式的能力，这意味着文档建立索引的时候无需明确指定每个
        
          <p class="article-more-link">
            <a href="/2021/06/22/elsticSearch/#more">阅读全文</a>
          </p>
        
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-factory" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/07/factory/">Java 工厂模式</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2021/06/07/factory/" class="article-date">
  <time datetime="2021-06-07T09:12:16.000Z" itemprop="datePublished">2021-06-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E5%AE%9D%E5%85%B8/">知识宝典</a>
  </div>

    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-mac" itemprop="articleBody">
      
        Java 工厂模式
1. Java接口回顾
 1. Java中接口的概念
    在Java中接口是一种特殊的抽象类，根一般的抽象类相比，接口里面的所有方法都是抽象方法，接口里面的所有属性都是常量。即接口里面只有方法定义而没有任何方法实现
    
    
 2. 接口的用途
    通常用接口来定义实现类的外观，也就是实现类的行为定义，用来约束实现类的行为。接口就相当于一份契约，根据外部应用需要的功能，约定了实现类应该要实现的功能，但是具体的实现类除了实现接口约定的功能外，还可以根据需要实现其他一些功能，这是允许的，也就是说实现类的功能包含但不仅限于接口约束的功能。 
    
    

        
          <p class="article-more-link">
            <a href="/2021/06/07/factory/#more">阅读全文</a>
          </p>
        
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-offer-2" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/28/offer-2/">Java网络通信</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2021/05/28/offer-2/" class="article-date">
  <time datetime="2021-05-28T15:16:21.000Z" itemprop="datePublished">2021-05-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E5%AE%9D%E5%85%B8/">知识宝典</a>
  </div>

    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-mac" itemprop="articleBody">
      
        Java网络通信篇
1. TCP和UDP有什么区别？TCP为什么是三次而不是两次？
TCP Transfer Control Protocol 是一种面向连接的、可靠的、传输层协议。
特点：好比是打电话，面向连接的，点对点的通信，高可靠的，效率比较低，占用的资源比较多。
UDP User Datagram Protocal 是一种无连接的，不可靠的，传输层协议
特点：好比是广播，不需要连接，发送方不管接收方有没有准备好，直接发消息；可以进行广播发送的；传输不可靠，有可能丢失消息，效率会比较高；协议就会比较简单，占用的系统资源就比较少。

TCP建立连接三次握手，断开连接四次挥手。如果两次握手，
        
          <p class="article-more-link">
            <a href="/2021/05/28/offer-2/#more">阅读全文</a>
          </p>
        
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-offer-1" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/28/offer-1/">Java 线程与锁机制</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2021/05/28/offer-1/" class="article-date">
  <time datetime="2021-05-28T15:16:08.000Z" itemprop="datePublished">2021-05-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E5%AE%9D%E5%85%B8/">知识宝典</a>
  </div>

    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-mac" itemprop="articleBody">
      
        Java 线程与锁机制
1. Java 如何开启线程
线程与进程的区别：进程是操作系统进行资源分配的最小单元；进程是操作系统进行任务分配的最小单元，线程隶属于进程。

开启线程的四种方式：

 * 继承Thread类，重写run方法； 
 * 实现Runnable接口，实现run方法；
 * 实现Callable接口，实现Call方法；
 * 通过线程池开启线程。

线程安全是指什么：多线程情况下，调用同一个对象都能得到正确的返回结果，即线程安全。
怎样保证线程安全：加锁：1. JVM提供的锁，即Syncchronized关键字； 2. JDK提供的各种锁Lock

 1. 继承Thread类
        
          <p class="article-more-link">
            <a href="/2021/05/28/offer-1/#more">阅读全文</a>
          </p>
        
      
    </div>
    
  </div>
  
  
</article>

  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页 &amp;raquo;</a>
  </nav>


</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box">
    <img class="avatar" src="/images/default-avatar.jpg" title="图片来自网络"></img>
    <h3 class="avatar-name">
      
        牧羊使的传说
      
    </h3>
    <p class="avatar-slogan">
      你从远处来，恰逢我在。
    </p>
  </div>
</div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/">入门教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E6%90%AD%E5%BB%BA/">工具搭建</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%9F%A5%E8%AF%86%E5%AE%9D%E5%85%B8/">知识宝典</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/">项目配置</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 15px;">中间件</a>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">时光轴</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/12/23/java-tomcat-filter-color-parse/">java filter 解析网关入参</a>
          </li>
        
          <li>
            <a href="/2022/02/09/java-jvm-config/">java-jvm-config</a>
          </li>
        
          <li>
            <a href="/2021/10/23/java-spi/">Java SPI 应用</a>
          </li>
        
          <li>
            <a href="/2021/09/05/self-spring-tag/">java 自定义spring标签</a>
          </li>
        
          <li>
            <a href="/2021/08/30/static-inner-class/">静态内部类</a>
          </li>
        
      </ul>
    </div>
  </div>

  
      <div class="widget-box">
    <h3 class="widget-title">友链</h3>
    <div class="widget">
      
        <a style="display: block;" href="https://github.com/201619825" title target='_blank'
        >遗世、遇夕</a>
      
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  <div class="foot-box global-width">
    &copy; 2023 遗世、遇夕 &nbsp;&nbsp;
    驱动于 <a href="http://hexo.io/" target="_blank">Hexo</a>
    &nbsp;|&nbsp;主题 <a href="https://github.com/yiluyanxia/hexo-theme-antiquity" target="_blank" rel="noopener">antiquity</a>
    <br>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">牧羊使的传说告之   阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
  </div>
</footer>
      <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script>
if (!window.jQuery) {
var script = document.createElement('script');
script.src = "/js/jquery-2.0.3.min.js";
document.body.write(script);
}
</script>

  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">档案</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/haru02.model.json"},"display":{"position":"right","width":180,"height":360},"mobile":{"show":true},"react":{"opacity":0.9}});</script></body>
</html>
<script type="text/javascript">
    //只在桌面版网页启用特效
  var windowWidth = $(window).width();
  if (windowWidth > 768) {
      document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>');
  }
</script>