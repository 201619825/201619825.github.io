<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>java jdk动态代理 | 遗世、遇夕</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta name="description" content="JDK动态代理（AOP）使用及实现原理分析 1. 前言 介绍:我们需要掌握的程度  动态代理(理解) 基于反射机制  掌握的程度:   * 什么是动态代理?          * 动态代理能够做什么?          后面我们在用Spirng和Mybatis的时候,要理解怎么使用的.   1. 什么是代理?     代理,在我们日常生活之中就有体现,代购,中介,换ip,商家等等，比如有一家美国的">
<meta property="og:type" content="article">
<meta property="og:title" content="java jdk动态代理">
<meta property="og:url" content="https://201619825.github.io/2021/04/20/jdk-dynamic-proxy/index.html">
<meta property="og:site_name" content="遗世、遇夕">
<meta property="og:description" content="JDK动态代理（AOP）使用及实现原理分析 1. 前言 介绍:我们需要掌握的程度  动态代理(理解) 基于反射机制  掌握的程度:   * 什么是动态代理?          * 动态代理能够做什么?          后面我们在用Spirng和Mybatis的时候,要理解怎么使用的.   1. 什么是代理?     代理,在我们日常生活之中就有体现,代购,中介,换ip,商家等等，比如有一家美国的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-04-20T11:47:39.000Z">
<meta property="article:modified_time" content="2022-06-22T10:33:09.124Z">
<meta property="article:author" content="遗世、遇夕">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="遗世、遇夕" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/default-avatar.jpg">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/highlight.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="fullpage" class="mobile-nav-right">
    
      <div id="wrapper" title="图片来自网络">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-right">
      
        <a class="nav-item" href="/" title
        
        >首页</a>
      
        <a class="nav-item" href="/archives" title
        
        >档案</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-right">
        <section id="main"><article id="post-jdk-dynamic-proxy" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 class="article-title" itemprop="name">
      java jdk动态代理
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2021/04/20/jdk-dynamic-proxy/" class="article-date">
  <time datetime="2021-04-20T11:47:39.000Z" itemprop="datePublished">2021-04-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E5%AE%9D%E5%85%B8/">知识宝典</a>
  </div>

    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

  </div>
  
    <span id="busuanzi_container_page_pv">
      本文总阅读量<span id="busuanzi_value_page_pv"></span>次
    </span>
  

  <div class="article-inner">
    
    <div class="article-content article-content-mac" itemprop="articleBody">
      
        <blockquote>
<h1 id="JDK动态代理（AOP）使用及实现原理分析"><a href="#JDK动态代理（AOP）使用及实现原理分析" class="headerlink" title="JDK动态代理（AOP）使用及实现原理分析"></a>JDK动态代理（AOP）使用及实现原理分析</h1></blockquote>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>介绍:我们需要掌握的程度</p>
<p>动态代理(理解) 基于反射机制</p>
<p>掌握的程度:</p>
<ul>
<li><p>什么是动态代理?</p>
</li>
<li><p>动态代理能够做什么?</p>
</li>
</ul>
<p>后面我们在用Spirng和Mybatis的时候,要理解怎么使用的.</p>
<ol>
<li>什么是代理?<br>代理,在我们日常生活之中就有体现,代购,中介,换ip,商家等等，比如有一家美国的大学,可以对全世界招生.留学中介(代理 )，留学中介(代理):帮助这家美国的学校招生,中介是学校的代理中介是代替学校完成招生功能，代理特点：</li>
</ol>
<p>中介和代理他们要做的事情是一致的:招生<br>中介是学校代理,学校是目标<br>家长——–&gt;中介(学校介绍,办理入学手续)———-&gt;美国学校<br>中介是代理,收取费用<br>2. 为什么要找中介<br>为什么要找中介?</p>
<ul>
<li>中介是专业的,方便.</li>
<li>家长现在不能自己去找学校。家长没有能力访问学校.或者美国学校不接收个人来访</li>
</ul>
<p>买东西都是商家卖, 商家是某个商品的代理, 你个人买东西,肯定不会让你接触到厂家的.</p>
<h2 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h2><ul>
<li>2.1 使用代理模式的作用<br>&nbsp;&nbsp;功能增强:在你原有的功能上,增加了额外的功能.新增加的功能,叫做功能增强<br>&nbsp;&nbsp;控制访问:代理类不让你访问目标,例如商家不让用户访问厂家</li>
<li>2.2 实现代理的方式</li>
</ul>
<p>1.静态代理:</p>
<p>1)代理类是自己手工实现的,自己创建一个java类,表示代理类</p>
<p>2)同时你所要代理的目标</p>
<p>特点：1）实现简单 2）容易理解。<br>模拟一个用户购买u盘的行为。<br>用户是客户端类<br>商家：代理，代理某个品牌的u盘。<br>厂家：目标类。<br>三者的关系：用户（客户端）-—-商家（代理）-—-厂家（目标）<br>商家和厂家都是卖u盘的，他们完成的功能是一致的，都是卖u盘。<br>实现步骤:<br>&nbsp;&nbsp;1. 创建一个接口,定义卖u盘的方法,表示你的厂家和商家做的事情<br>&nbsp;&nbsp;2. 创建厂家类,实现1步骤的接口<br>&nbsp;&nbsp;3. 创建商家,就是代理,也需要实现1步骤中的接口<br>&nbsp;&nbsp;4. 创建客户端类,调用商家的方法买一个u盘</p>
<ul>
<li>2.3 具体实现</li>
</ul>
<p>实现步骤:</p>
<ol>
<li><p>创建一个接口,定义卖u盘的方法,表示你的厂家和商家做的事情</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.rango.service;</span><br><span class="line">public interface usbSell &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义一个方法 参数 amount:表示一次购买的数量,暂时不用</span><br><span class="line">     * 返回值表示一个u盘的价格</span><br><span class="line">     * @param amount</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    float sell(int amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>创建厂家类,实现1步骤的接口</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.rango.factory;</span><br><span class="line"></span><br><span class="line">import com.rango.service.usbSell;</span><br><span class="line">&#x2F;&#x2F;目标类:金士顿厂家,不接受用户的单独购买</span><br><span class="line">public class UsbKingFactory implements usbSell &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义一个方法 参数 amount:表示一次购买的数量,暂时不用</span><br><span class="line">     * 返回值表示一个u盘的价格</span><br><span class="line">     *</span><br><span class="line">     * @param amount</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">&#x2F;&#x2F;一个128G的U盘是85元.</span><br><span class="line">&#x2F;&#x2F;    后期根据amount,可以实现不同的价格,例如10000个,单击是80,50000个75</span><br><span class="line">    public float sell(int amount) &#123;</span><br><span class="line">        return 85.0f*amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><p>创建商家,就是代理,也需要实现1步骤中的接口</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.rango.business;</span><br><span class="line"></span><br><span class="line">import com.rango.factory.UsbKingFactory;</span><br><span class="line">import com.rango.service.usbSell;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;淘宝是一个商家,代理金士顿U盘的销售</span><br><span class="line">public class TaoBao implements usbSell &#123;</span><br><span class="line">&#x2F;&#x2F;      声明 商家代理的厂家具体是谁</span><br><span class="line">    private UsbKingFactory factory &#x3D;new UsbKingFactory();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">&#x2F;&#x2F;    实现销售U盘功能</span><br><span class="line">    public float sell(int amount) &#123;</span><br><span class="line">&#x2F;&#x2F;        向厂家发送订单,告诉厂家,我买了U盘,厂家发货</span><br><span class="line">&#x2F;&#x2F;        发送给工厂,我需要的订单,返回报价</span><br><span class="line">        float price &#x3D; factory.sell(amount);</span><br><span class="line">&#x2F;&#x2F;        商家需要加价也就是代理要增加价格</span><br><span class="line">        price &#x3D; price + 25;</span><br><span class="line">&#x2F;&#x2F;在目标类的方法调用后,你做的其他功能,都是增强的意思</span><br><span class="line">        System.out.println(&quot;淘宝再给你返回一个优惠券,或者红包&quot;);</span><br><span class="line">&#x2F;&#x2F;        增加的价格</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><p>创建客户端类,调用商家的方法买一个u盘</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import com.rango.business.TaoBao;</span><br><span class="line"></span><br><span class="line">public class shopMain &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">&#x2F;&#x2F;             创建代理的商家淘宝对象</span><br><span class="line">        TaoBao taoBao &#x3D; new TaoBao();</span><br><span class="line">&#x2F;&#x2F;        我只向淘宝买一件产品,得到报价</span><br><span class="line">        float price &#x3D; taoBao.sell(2);</span><br><span class="line">        System.out.println(&quot;购买一件产品.淘宝的报价为: &quot;+price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>所以我们再次总结代理类完成的功能:</p>
</li>
</ol>
<p>目标类中方法的调用<br>功能增强<br>所属我们只有一个代理商,我们实际上可以写多个代理商,</p>
<ul>
<li>2.4 静态代理的优缺点<br>我们再次总结一下静态代理的优缺点</li>
</ul>
<p>优点:</p>
<p>实现简单<br>容易简单<br>确定:当你的项目中,目标类的代理类很多的时候,有一下的缺点</p>
<p>当目标类增加了,代理类可能也需要成倍的增加<br>当你的接口中功能在增加了,或者修改了,会影响众多的实现类,厂家类,代理都需要修改,影响比较多.<br>所以我们继续学习动态代理</p>
<h2 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h2><p>本章,我们所掌握的是</p>
<ul>
<li>什么是动态代理?</li>
</ul>
<p>​ 使用jdk的反射机制,创建对象的能力,创建的是代理类的的对象.而不用我们创建类文件,不用写java文件, 什么叫动态?在程序执行时,调用jdk提供的方法才能创建代理类的对象</p>
<ul>
<li>知道动态代理能做什么?</li>
</ul>
<ul>
<li>2.1 静态代理和动态代理模式的对比<br>在静态代理中目标很多的时候,可以使用动态代理,避免静态代理的缺点</li>
</ul>
<p>在静态代理中目标类很多时候,可以使用动态代理,避免静态代理的缺点。<br>动态代理中目标类即使很多,</p>
<p>代理类数量可以很少,</p>
<p>当你修改了接口中的方法时,不会影响代理类。</p>
<p>动态代理:在程序执行过程中,使用jdk的反射机制,创建代理类对象,并动态的指定要代理目标类。<br>换句话说:动态代理是一种创建java象的能力,让你不用创建 TaoBao类就能创建代理类对象,除去了中间商</p>
<p>在java中,要想创建对象</p>
<p>创建类文件,java 文件编译为class<br>使用构造方法,创建类的对象</p>
<ul>
<li>2.2 动态代理的介绍</li>
</ul>
<p>动态代理是指代理类对象在程序运行时由JVM根据反射机制动态生成的。动态代理不需要定义代理类的，java源文件。<br>动态代理其实就是jdk运行期间，动态创建class字节码并加载到JVM。<br>动态代理的实现方式常用的有两种：使用JDK代理，与通过CGLlB动态代理。<br>动态代理的实现:</p>
<p>jdk动态代理(理解):使用java反射包中的类和接口实现动态代理的功能,反射包java.lang.reflect,里面有三个类:InvocationHandler,Method,Proxy<br>cglib动态代理(了解): cglib是第三方的工具库,创建代理对象<br>cglib的原理是继承，cglib通过继承目标类，创建它的子类，在子类中<br>重写父类中同名的方法，实现功能的修改。<br>因为cglib是继承，重写方法，所以要求目标类不能是fina1的，方法也不能是final的。cglib的要求目标类比较宽松，只要能继承就可以了。cglib在很多的框架中使用，<br>比如mybatis，spring框架中都有使用。</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package Test;</span><br><span class="line"></span><br><span class="line">import com.rango.Impl.HelloServiceImpl;</span><br><span class="line">import com.rango.service.HelloService;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class TestApp &#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">&#x2F;&#x2F;        HelloService service &#x3D; new HelloServiceImpl();</span><br><span class="line">&#x2F;&#x2F;        service.sayhello(&quot;张三&quot;);</span><br><span class="line">&#x2F;&#x2F;        以上是常规方法执行sayhello</span><br><span class="line">&#x2F;&#x2F;        下面我们使用反射机制进行创建sayhello方法,核心Method(类中的方法)</span><br><span class="line">        HelloServiceImpl target &#x3D; new HelloServiceImpl();</span><br><span class="line">&#x2F;&#x2F;        获取sayhello名称对应的Method类对象</span><br><span class="line">&#x2F;&#x2F;         public Method getM   ethod(String name, Class&lt;?&gt;... parameterTypes)</span><br><span class="line">&#x2F;&#x2F;        加入,该方法的参数有多个该怎么办?</span><br><span class="line">&#x2F;&#x2F;        parameterTypes参数是一个类对象数组，按声明的顺序标识方法的形式参数类型。</span><br><span class="line">        Method method &#x3D; HelloService.class.getMethod(&quot;sayhello&quot;, String.class);</span><br><span class="line">&#x2F;&#x2F;        通过Metho可以执行sayhello方法的调用</span><br><span class="line">        &#x2F;*</span><br><span class="line">        *  public Object invoke(Object obj, Object... args)</span><br><span class="line">        *       表示执行方法的调用</span><br><span class="line">        *   参数:</span><br><span class="line">        *       1.Object,表示对象,要执行这个对象的方法</span><br><span class="line">        *       2.Object...args,方法执行时的参数值</span><br><span class="line">        * 返回值:</span><br><span class="line">        *       Object:方法执行后的返回值</span><br><span class="line">        * *&#x2F;</span><br><span class="line">        Object ret &#x3D; method.invoke(target, &quot;李四&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>2.3 回顾反射 Method类</li>
</ul>
<ul>
<li><p>2.2.1 class.getMethod</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method method &#x3D; HelloService.class.getMethod(&quot;sayhello&quot;, String.class,Integer.class);</span><br></pre></td></tr></table></figure></div>
<p>提出问题?</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</span><br></pre></td></tr></table></figure></div>
<p>加入,该方法的参数有多个该怎么办?<br>parameterTypes参数是一个类对象数组，按声明的顺序标识方法的形式参数类型。</p>
</li>
<li><p>2.2.2 Method.invoke</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object obj,Object... args)</span><br><span class="line"></span><br><span class="line">*  public Object invoke(Object obj, Object... args)</span><br><span class="line">*       表示执行方法的调用</span><br><span class="line">*   参数:</span><br><span class="line">*       1.Object,表示对象,要执行这个对象的方法</span><br><span class="line">*       2.Object...args,方法执行时的参数值</span><br><span class="line">* 返回值:</span><br><span class="line">*       Object:方法执行后的返回值</span><br><span class="line">*</span><br></pre></td></tr></table></figure></div></li>
</ul>
<ul>
<li>2.4 JDK动态代理</li>
</ul>
<p>实现步骤</p>
<ol>
<li>创建一个接口,定义卖u盘的方法,表示你的厂家和商家做的事情</li>
</ol>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.rango.service;</span><br><span class="line">public interface usbSell &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义一个方法 参数 amount:表示一次购买的数量,暂时不用</span><br><span class="line">     * 返回值表示一个u盘的价格</span><br><span class="line">     * @param amount</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    float sell(int amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>创建厂家类,实现1步骤的接口</li>
</ol>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.rango.factory;</span><br><span class="line"></span><br><span class="line">import com.rango.service.usbSell;</span><br><span class="line">&#x2F;&#x2F;目标类:金士顿厂家,不接受用户的单独购买</span><br><span class="line">public class UsbKingFactory implements usbSell &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义一个方法 参数 amount:表示一次购买的数量,暂时不用</span><br><span class="line">     * 返回值表示一个u盘的价格</span><br><span class="line">     *</span><br><span class="line">     * @param amount</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">&#x2F;&#x2F;一个128G的U盘是85元.</span><br><span class="line">&#x2F;&#x2F;    后期根据amount,可以实现不同的价格,例如10000个,单击是80,50000个75</span><br><span class="line">    public float sell(int amount) &#123;</span><br><span class="line">        return 85.0f*amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ol start="3">
<li>创建商家,就是代理,也需要实现1步骤中的接口</li>
</ol>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.rango.business;</span><br><span class="line"></span><br><span class="line">import com.rango.factory.UsbKingFactory;</span><br><span class="line">import com.rango.service.usbSell;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;淘宝是一个商家,代理金士顿U盘的销售</span><br><span class="line">public class TaoBao implements usbSell &#123;</span><br><span class="line">&#x2F;&#x2F;      声明 商家代理的厂家具体是谁</span><br><span class="line">    private UsbKingFactory factory &#x3D;new UsbKingFactory();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">&#x2F;&#x2F;    实现销售U盘功能</span><br><span class="line">    public float sell(int amount) &#123;</span><br><span class="line">&#x2F;&#x2F;        向厂家发送订单,告诉厂家,我买了U盘,厂家发货</span><br><span class="line">&#x2F;&#x2F;        发送给工厂,我需要的订单,返回报价</span><br><span class="line">        float price &#x3D; factory.sell(amount);</span><br><span class="line">&#x2F;&#x2F;        商家需要加价也就是代理要增加价格</span><br><span class="line">        price &#x3D; price + 25;</span><br><span class="line">&#x2F;&#x2F;在目标类的方法调用后,你做的其他功能,都是增强的意思</span><br><span class="line">        System.out.println(&quot;淘宝再给你返回一个优惠券,或者红包&quot;);</span><br><span class="line">&#x2F;&#x2F;        增加的价格</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ol start="4">
<li>创建客户端类,调用商家的方法买一个u盘</li>
</ol>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import com.rango.business.TaoBao;</span><br><span class="line"></span><br><span class="line">public class shopMain &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">&#x2F;&#x2F;             创建代理的商家淘宝对象</span><br><span class="line">        TaoBao taoBao &#x3D; new TaoBao();</span><br><span class="line">&#x2F;&#x2F;        我只向淘宝买一件产品,得到报价</span><br><span class="line">        float price &#x3D; taoBao.sell(2);</span><br><span class="line">        System.out.println(&quot;购买一件产品.淘宝的报价为: &quot;+price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>所以我们再次总结代理类完成的功能:</p>
<p>目标类中方法的调用<br>功能增强<br>所属我们只有一个代理商,我们实际上可以写多个代理商,</p>
<ul>
<li>2.5 静态代理的优缺点<br>我们再次总结一下静态代理的优缺点</li>
</ul>
<p>优点:</p>
<p>实现简单<br>容易简单<br>确定:当你的项目中,目标类的代理类很多的时候,有一下的缺点</p>
<p>当目标类增加了,代理类可能也需要成倍的增加<br>当你的接口中功能在增加了,或者修改了,会影响众多的实现类,厂家类,代理都需要修改,影响比较多.<br>所以我们继续学习动态代理</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package Test;</span><br><span class="line"></span><br><span class="line">import com.rango.Impl.HelloServiceImpl;</span><br><span class="line">import com.rango.service.HelloService;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class TestApp &#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">&#x2F;&#x2F;        HelloService service &#x3D; new HelloServiceImpl();</span><br><span class="line">&#x2F;&#x2F;        service.sayhello(&quot;张三&quot;);</span><br><span class="line">&#x2F;&#x2F;        以上是常规方法执行sayhello</span><br><span class="line">&#x2F;&#x2F;        下面我们使用反射机制进行创建sayhello方法,核心Method(类中的方法)</span><br><span class="line">        HelloServiceImpl target &#x3D; new HelloServiceImpl();</span><br><span class="line">&#x2F;&#x2F;        获取sayhello名称对应的Method类对象</span><br><span class="line">&#x2F;&#x2F;         public Method getM   ethod(String name, Class&lt;?&gt;... parameterTypes)</span><br><span class="line">&#x2F;&#x2F;        加入,该方法的参数有多个该怎么办?</span><br><span class="line">&#x2F;&#x2F;        parameterTypes参数是一个类对象数组，按声明的顺序标识方法的形式参数类型。</span><br><span class="line">        Method method &#x3D; HelloService.class.getMethod(&quot;sayhello&quot;, String.class);</span><br><span class="line">&#x2F;&#x2F;        通过Metho可以执行sayhello方法的调用</span><br><span class="line">        &#x2F;*</span><br><span class="line">        *  public Object invoke(Object obj, Object... args)</span><br><span class="line">        *       表示执行方法的调用</span><br><span class="line">        *   参数:</span><br><span class="line">        *       1.Object,表示对象,要执行这个对象的方法</span><br><span class="line">        *       2.Object...args,方法执行时的参数值</span><br><span class="line">        * 返回值:</span><br><span class="line">        *       Object:方法执行后的返回值</span><br><span class="line">        * *&#x2F;</span><br><span class="line">        Object ret &#x3D; method.invoke(target, &quot;李四&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>jdk动态代理:<br>1.反射, Method类,表示方法。类中的方法。通过Method可以执行某个方法</p>
<p>2.jdk动态代理的实现<br>反射包java.lang. reflect,里面有三个类：InvocationHandler，Method，Proxy</p>
<ul>
<li>2.3.1 Interface InvocationHandler<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface InvocationHandler</span><br></pre></td></tr></table></figure></div>
InvocationHandler是由代理实例的调用处理程序实现的接口 。<br>每个代理实例都有一个关联的调用处理程序。 当在代理实例上调用方法时，方法调用将被编码并分派到其调用处理程序的invoke方法。<br>InvocationHandler接口(调用处理器):就一个方法 invoke()<br>​invoke():表示代理对象要执行的功能代码。你的代理类要完成的功能就写在<br>​invoke（）方法中。</li>
</ul>
<p>代理类完成的功能<br>    1.调用目标方法,执行目标方法的功能<br>    2.功能增强,在目标方法调用时,增加功能<br>方法原型:</p>
<p>参数：object proxy：jdk创建的代理对象，无需赋值。<br>                Method method:目标类中的方法，jdk提供method对象的<br>                object[]args:目标类中方法的参数，jdk提供的。<br>Object invoke(Object proxy,方法 method,Object[] args)throws Throwable处理代理实例上的方法调用并返回结果。</p>
<ul>
<li>2.3.2 Method<br>Method类:表示方法的,确切的说就是目标类中的方法。</li>
</ul>
<p>作用:通过 Method可以执行某个目标类的方法, Method. invoke();<br>method. invoke(目标对象,方法的参数)</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">​ object ret&#x3D; method. invoke(service22,&quot;李四&quot;)</span><br><span class="line"></span><br><span class="line">说明:method.invoke()就是为了用来执行目标方法的,等同于静态代理中的</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;        向厂家发送订单,告诉厂家,我买了U盘,厂家发货</span><br><span class="line">    &#x2F;&#x2F;        发送给工厂,我需要的订单,返回报价</span><br><span class="line">            float price &#x3D; factory.sell(amount);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>2.3.3 Proxy类<br>proxy类：核心的对象，创建代理对象。之前创建对象都是new类的构造方法（）<br>现在我们是使用proxy类的方法，代替new的使用。<br>方法：静态方法 newProxyInstance(）<br>作用是：创建代理对象，等同于静态代理中的TaoBao taoBao=new TaoBao()</li>
</ul>
<p>我们来观察方法原型</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance( ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)   throws IllegalArgumentException</span><br></pre></td></tr></table></figure></div>
<p>参数:</p>
<p>ClassLoader loader 类加载器,负责向内存中加载对象的,使用反射机制获取对象的classLoader,<br>如何获取? 类 a, a.getCalss().getClassLoader(),目标对象的类加载器</p>
<p>这里我们细分:每一个类都继承Object类,在Object中有一个getClass方法,表示 类对象的运行时类的Class对象。 而Class类里面有一个public ClassLoader getClassLoader()方法</p>
<p>Class&lt;?&gt;[] interfaces: 接口,目标对象实现的接口,也是反射获取的<br>InvocationHandler h : 我们自己写的,代理类要完成的功能<br>返回值也就是代理对象</p>
<h2 id="4-实现动态代理的步骤"><a href="#4-实现动态代理的步骤" class="headerlink" title="4. 实现动态代理的步骤"></a>4. 实现动态代理的步骤</h2><p>创建接口,定义目标类要完成的功能<br>创建目标类实现接口<br>创建InvocationHandler接口的实现类,在invoke方法中完成代理类的功能<br>调用目标方法<br>增强功能<br>使用Proxy类的静态方法,创建代理对象,并把返回值转换成接口类型<br>第一步:创建接口,定义目标所需功能</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UsbSell &#123;</span><br><span class="line">    float sell(int amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>第二步:创建目标类实现接口</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class UsbKingFactory implements UsbSell &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public float sell(int amount) &#123;</span><br><span class="line">        System.out.println(&quot;目标类中,执行了sell目标方法&quot;);</span><br><span class="line">        return 85.02f;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>我们写了接口类,定义了功能,写了代理类,实现了接口功能,按照以前的操作,现在就需要写一个真正的代理类,创建对象.</p>
<p>第三步: 创建Invocationhandler实现类.在invoke()方法中完成代理类的对象</p>
<p>​ 1.调用目标的方法</p>
<p>​ 2.增强功能</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyHandle implements InvocationHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>我们就在以前代理类的实现方法上进行修改</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;之前的代理类</span><br><span class="line">  public class TaoBao implements usbSell &#123;</span><br><span class="line">    &#x2F;&#x2F;      声明 商家代理的厂家具体是谁</span><br><span class="line">        private UsbKingFactory factory &#x3D;new UsbKingFactory();</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">    &#x2F;&#x2F;    实现销售U盘功能</span><br><span class="line">        public float sell(int amount) &#123;</span><br><span class="line">    &#x2F;&#x2F;        向厂家发送订单,告诉厂家,我买了U盘,厂家发货</span><br><span class="line">    &#x2F;&#x2F;        发送给工厂,我需要的订单,返回报价</span><br><span class="line">            float price &#x3D; factory.sell(amount);</span><br><span class="line">    &#x2F;&#x2F;        商家需要加价也就是代理要增加价格</span><br><span class="line">            price &#x3D; price + 25;</span><br><span class="line">    &#x2F;&#x2F;在目标类的方法调用后,你做的其他功能,都是增强的意思</span><br><span class="line">            System.out.println(&quot;淘宝再给你返回一个优惠券,或者红包&quot;);</span><br><span class="line">    &#x2F;&#x2F;        增加的价格</span><br><span class="line">            return price;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>调用目标的方法</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;传入是谁的对象,就给谁创建代理</span><br><span class="line">    public MyHandle(Object target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line">invoke里面的设置</span><br><span class="line">                Object res &#x3D;null;</span><br><span class="line">            &#x2F;&#x2F;        向厂家发送订单,告诉厂家,我买了U盘,厂家发货</span><br><span class="line">            &#x2F;&#x2F;        发送给工厂,我需要的订单,返回报价</span><br><span class="line">&#x2F;&#x2F;            float price &#x3D; factory.sell(amount);</span><br><span class="line">            res &#x3D; method.invoke(target,args);       &#x2F;&#x2F;待执行目标方法,执行后返回值</span><br></pre></td></tr></table></figure></div>
<p>第四步: 使用Proxy类的静态方法,创建代理对象,并把返回值转换成接口类型</p>
<p>创建一个MainShop类.</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MainShop &#123;</span><br><span class="line">    public static void main(String[] args)&#123; </span><br><span class="line">&#x2F;&#x2F;            1.创建对象,使用Proxy</span><br><span class="line">&#x2F;&#x2F;            2.创建目标对象</span><br><span class="line">        UsbSell factory &#x3D; new UsbKingFactory();</span><br><span class="line">&#x2F;&#x2F;        3.创建Invocationhandler对象</span><br><span class="line">        InvocationHandler myHandle &#x3D; new MyHandle(factory);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        4.创建代理对象</span><br><span class="line">        UsbSell proxy &#x3D; (UsbSell) Proxy.newProxyInstance(factory.getClass().getClassLoader(),</span><br><span class="line">                factory.getClass().getInterfaces(),</span><br><span class="line">                myHandle);</span><br><span class="line">&#x2F;&#x2F;        通过代理执行方法</span><br><span class="line">        float price &#x3D; proxy.sell(1);</span><br><span class="line">        System.out.println(&quot;通过动态代理对象,调用方法:&quot; +price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>执行成功.和之前动态代理模式一样</p>
<p>第五 JDK动态代理执行流程<br>我们先复习一下,Proxy类,实现动态代理的流程,使用返回指定接口的代理类实例,</p>
<p>我们此时debug一下程序,在invok实现类中打一个断点</p>
<p>此时我们再观察,代理对象MyHandler里面的invoke方法的参数</p>
<h3 id="参考链接：https-www-cnblogs-com-jia0504-p-13811424-html"><a href="#参考链接：https-www-cnblogs-com-jia0504-p-13811424-html" class="headerlink" title="参考链接：https://www.cnblogs.com/jia0504/p/13811424.html"></a>参考链接：<a href="https://www.cnblogs.com/jia0504/p/13811424.html" target="_blank" rel="noopener">https://www.cnblogs.com/jia0504/p/13811424.html</a></h3><h3 id="Mybatis插件精品文章：https-www-cnblogs-com-qdhxhz-p-11390778-html"><a href="#Mybatis插件精品文章：https-www-cnblogs-com-qdhxhz-p-11390778-html" class="headerlink" title="Mybatis插件精品文章：https://www.cnblogs.com/qdhxhz/p/11390778.html"></a>Mybatis插件精品文章：<a href="https://www.cnblogs.com/qdhxhz/p/11390778.html" target="_blank" rel="noopener">https://www.cnblogs.com/qdhxhz/p/11390778.html</a></h3>
      
    </div>
    
      <footer class="article-footer">
        完
      </footer>
    
  </div>
  
    
<nav id="article-nav">
  <div class="article-nav-block">
    
      <a href="/2021/04/20/self-param-anno/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption"></strong>
        <div class="article-nav-title">
          
            java 自定义参数解析器
          
        </div>
      </a>
    
  </div>
  <div class="article-nav-block">
    
      <a href="/2021/04/10/spring-base/" id="article-nav-older" class="article-nav-link-wrap">
        <div class="article-nav-title">spring应用上下文</div>
        <strong class="article-nav-caption"></strong>
      </a>
    
  </div>
</nav>

    <link rel="stylesheet" href="/css/gitment.css"> 
<script src="/js/gitment.js"></script>

<div id="gitmentContainer"></div>

<script>
var gitment = new Gitment({
  owner: '',
  repo: '',
  oauth: {
    client_id: '',
    client_secret: '',
  },
})
gitment.render('gitmentContainer')
</script>

  
  
</article>
</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box">
    <img class="avatar" src="/images/default-avatar.jpg" title="图片来自网络"></img>
    <h3 class="avatar-name">
      
        牧羊使的传说
      
    </h3>
    <p class="avatar-slogan">
      你从远处来，恰逢我在。
    </p>
  </div>
</div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/">入门教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E6%90%AD%E5%BB%BA/">工具搭建</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%9F%A5%E8%AF%86%E5%AE%9D%E5%85%B8/">知识宝典</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/">项目配置</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 15px;">中间件</a>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">时光轴</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/12/23/java-tomcat-filter-color-parse/">java filter 解析网关入参</a>
          </li>
        
          <li>
            <a href="/2022/02/09/java-jvm-config/">java-jvm-config</a>
          </li>
        
          <li>
            <a href="/2021/10/23/java-spi/">Java SPI 应用</a>
          </li>
        
          <li>
            <a href="/2021/09/05/self-spring-tag/">java 自定义spring标签</a>
          </li>
        
          <li>
            <a href="/2021/08/30/static-inner-class/">静态内部类</a>
          </li>
        
      </ul>
    </div>
  </div>

  
      <div class="widget-box">
    <h3 class="widget-title">友链</h3>
    <div class="widget">
      
        <a style="display: block;" href="https://github.com/201619825" title target='_blank'
        >遗世、遇夕</a>
      
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  <div class="foot-box global-width">
    &copy; 2023 遗世、遇夕 &nbsp;&nbsp;
    驱动于 <a href="http://hexo.io/" target="_blank">Hexo</a>
    &nbsp;|&nbsp;主题 <a href="https://github.com/yiluyanxia/hexo-theme-antiquity" target="_blank" rel="noopener">antiquity</a>
    <br>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">牧羊使的传说告之   阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
  </div>
</footer>
      <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script>
if (!window.jQuery) {
var script = document.createElement('script');
script.src = "/js/jquery-2.0.3.min.js";
document.body.write(script);
}
</script>

  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">档案</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/haru02.model.json"},"display":{"position":"right","width":180,"height":360},"mobile":{"show":true},"react":{"opacity":0.9}});</script></body>
</html>
<script type="text/javascript">
    //只在桌面版网页启用特效
  var windowWidth = $(window).width();
  if (windowWidth > 768) {
      document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>');
  }
</script>